import librosa
import numpy as np
import os
import glob
from sklearn.ensemble import RandomForestClassifier
from datetime import datetime

# Define paths
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
INPUT_DIR = os.path.join(BASE_DIR, "audio_input")
OUTPUT_DIR = os.path.join(BASE_DIR, "audio_output")

def extract_acoustic_features(audio_file):
    print(f"Processing {os.path.basename(audio_file)}...")
    try:
        y, sr = librosa.load(audio_file)
        
        # Extract features
        mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
        mfcc_mean = np.mean(mfcc, axis=1)
        
        chroma = librosa.feature.chroma_stft(y=y, sr=sr)
        chroma_mean = np.mean(chroma, axis=1)
        
        spec_cent = np.mean(librosa.feature.spectral_centroid(y=y, sr=sr))
        spec_bw = np.mean(librosa.feature.spectral_bandwidth(y=y, sr=sr))
        spec_rolloff = np.mean(librosa.feature.spectral_rolloff(y=y, sr=sr))
        zcr = np.mean(librosa.feature.zero_crossing_rate(y))
        
        features = np.concatenate([
            mfcc_mean, 
            chroma_mean, 
            [spec_cent, spec_bw, spec_rolloff, zcr]
        ])
        return features
        
    except Exception as e:
        print(f"Error processing {audio_file}: {e}")
        return None

def generate_report(filename, prediction, probability):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    report_content = f"""# Depression Mental Health Screening Report
    
**Date:** {timestamp}
**File:** {filename}
**Model:** Acoustic Feature Analysis (Random Forest)

## Results
- **Status:** {prediction}
- **Probability:** {probability:.2%}

## Analysis
The audio was analyzed for acoustic markers associated with depression (flat affect, pitch variance, spectral energy). The model suggests: **{prediction}**.

### Key metrics extracted:
- MFCCs (Timbre)
- Chroma (Pitch)
- Spectral Centroid (Brightness)

---
*Generated by Synapxe Health screening prototype*
"""
    
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    output_filename = os.path.splitext(filename)[0] + "_depression_report.md"
    output_path = os.path.join(OUTPUT_DIR, output_filename)
    
    with open(output_path, "w") as f:
        f.write(report_content)
    
    print(f"Report generated: {output_path}")

def main():
    if not os.path.exists(INPUT_DIR):
        os.makedirs(INPUT_DIR)
        print(f"Created input directory: {INPUT_DIR}")
    
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        print(f"Created output directory: {OUTPUT_DIR}")

    # Find audio files
    audio_files = []
    for ext in ["*.wav", "*.mp3", "*.flac"]:
        audio_files.extend(glob.glob(os.path.join(INPUT_DIR, ext)))
    
    if not audio_files:
        print(f"No audio files found in {INPUT_DIR}")
        return

    # Train dummy classifier once
    print("Initializing classifier...")
    # Mock data dimensions depends on feature count (13 + 12 + 4 = 29)
    X_dummy = np.random.rand(100, 29)
    y_dummy = np.random.randint(0, 2, 100)
    
    clf = RandomForestClassifier(n_estimators=100)
    clf.fit(X_dummy, y_dummy)

    for audio_file in audio_files:
        features = extract_acoustic_features(audio_file)
        
        if features is not None:
            prediction_idx = clf.predict([features])[0]
            probability = clf.predict_proba([features])[0][1]
            
            label = "Depression Risk" if prediction_idx == 1 else "Normal Range"
            generate_report(os.path.basename(audio_file), label, probability)

if __name__ == "__main__":
    main()
