import soundfile as sf
import torch
from speechbrain.inference.classifiers import EncoderClassifier
import os
import glob
import numpy as np
from sklearn.linear_model import LogisticRegression
from datetime import datetime

# Define paths
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
INPUT_DIR = os.path.join(BASE_DIR, "audio_input")
OUTPUT_DIR = os.path.join(BASE_DIR, "audio_output")

def extract_features(audio_file):
    print(f"Processing {os.path.basename(audio_file)}...")
    
    try:
        classifier = EncoderClassifier.from_hparams(source="speechbrain/spkrec-ecapa-voxceleb")
    except Exception as e:
        # Fallback if there are network/cache issues, though our previous fix should handle it
        import traceback
        traceback.print_exc()
        return None

    try:
        # Load audio using soundfile directly to avoid torchaudio backend issues
        signal_np, fs = sf.read(audio_file)
        
        # Convert to tensor
        signal = torch.from_numpy(signal_np).float()
        
        # Handle stereo/channels
        if len(signal.shape) > 1:
            if signal.shape[1] > 1:
                signal = signal.mean(dim=1) # mix to mono
        
        # Ensure (1, T) shape
        if len(signal.shape) == 1:
            signal = signal.unsqueeze(0)
            
        # Resample if needed (ECAPA expects 16k)
        if fs != 16000:
            import torchaudio.transforms as T
            resampler = T.Resample(fs, 16000)
            signal = resampler(signal)
            
        embeddings = classifier.encode_batch(signal)
        return embeddings.squeeze().detach().numpy()
        
    except Exception as e:
        print(f"Error processing {audio_file}: {e}")
        return None

def generate_report(filename, prediction, probability):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    report_content = f"""# Voice Fatigue Analysis Report
    
**Date:** {timestamp}
**File:** {filename}
**Model:** ECAPA-TDNN (SpeechBrain)

## Results
- **Status:** {prediction}
- **Confidence:** {probability:.2%}

## Analysis
The audio file was analyzed using deep speaker embeddings. The classifier detected patterns consistent with {prediction.lower()}.

---
*Generated by Synapxe Health screening prototype*
"""
    
    # Create output directory if it doesn't exist (redundant check but safe)
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    output_filename = os.path.splitext(filename)[0] + "_fatigue_report.md"
    output_path = os.path.join(OUTPUT_DIR, output_filename)
    
    with open(output_path, "w") as f:
        f.write(report_content)
    
    print(f"Report generated: {output_path}")

def main():
    if not os.path.exists(INPUT_DIR):
        os.makedirs(INPUT_DIR)
        print(f"Created input directory: {INPUT_DIR}")
    
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        print(f"Created output directory: {OUTPUT_DIR}")

    # Find all audio files
    audio_files = []
    # Check for wav, mp3, flac (case insensitive in Windows roughly, but good to be explicit if needed)
    for ext in ["*.wav", "*.mp3", "*.flac"]:
        audio_files.extend(glob.glob(os.path.join(INPUT_DIR, ext)))
    
    if not audio_files:
        print(f"No audio files found in {INPUT_DIR}")
        return

    # Train dummy classifier once
    print("Initializing classifier...")
    # Mock training data (192 dim embedding)
    X_dummy = np.random.rand(100, 192) 
    y_dummy = np.random.randint(0, 2, 100) # 0=Normal, 1=Fatigued
    clf = LogisticRegression()
    clf.fit(X_dummy, y_dummy)

    for audio_file in audio_files:
        features = extract_features(audio_file)
        
        if features is not None:
            # Inference
            prediction_idx = clf.predict([features])[0]
            probability = clf.predict_proba([features])[0][1]
            
            label = "Fatigued" if prediction_idx == 1 else "Normal"
            generate_report(os.path.basename(audio_file), label, probability)

if __name__ == "__main__":
    main()
